%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Floyd's Cycle Finding Algorithm (Linked List Cycle Detection)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Floyd's Cycle Finding Algorithm (Linked List Cycle Detection)}

\begin{figure}[H]
    Optimal Solution:\\\\
    \begin{tabular}{rl}
        Time Complexity:& \(O(m)\) where \(m\) is the number of nodes.\\
        Space Complexity:& \(O(m)\) where \(m\) is the number of nodes.
    \end{tabular}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minted}{python}
        from typing import Optional


        class ListNode:
            def __init__(self, val: int = 0, next: Optional[ListNode]):
                self._val = val
                self._next = next


        def floyd_cycle(head: ListNode) -> bool:
            """An implementation of Floyd's Cycle Finding Algorithm."""

            # Make sure that the linked list is not empty
            if not head:
                return False

            # Parameter specifying whether there is a cycle
            cycle: boolean = False

            # Initialize slow and fast pointers
            slow: Optional[ListNode] = head
            fast: Optional[ListNode] = head._next
            while not cycle:
                # If the fast or its next node does not exist, no cycles
                if not fast or not fast.next:
                    break

                # If the slow and fast pointers are the same, we have a cycle
                if slow == fast:
                    cycle = True
                    break

                # Advance both pointers
                slow = slow._next
                fast = fast._next._next

            return cycle
    \end{minted}
\end{figure}
