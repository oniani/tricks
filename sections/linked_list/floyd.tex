%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Floyd's Cycle Finding Algorithm (Linked List Cycle Detection)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Floyd's Cycle Finding Algorithm (Linked List Cycle Detection)}

\begin{figure}[H]
    Optimal Solution:\\\\
    \begin{tabular}{rl}
        Time Complexity:& \(O(m)\) where \(m\) is the number of nodes.\\
        Space Complexity:& \(O(m)\) where \(m\) is the number of nodes.
    \end{tabular}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{minted}{python}
        from typing import Optional


        class ListNode:
            def __init__(self, val: int = 0, next: Optional[ListNode]):
                self._val = val
                self._next = next


        def floyd_cycle(head: ListNode) -> bool:
            """An implementation of Floyd's Cycle Finding Algorithm."""

            # Make sure that the linked list is not empty
            if not head:
                return False

            # Initialize slow and fast pointers
            slow: Optional[ListNode] = head
            fast: Optional[ListNode] = head.next
            while slow != fast:
                # Check only `fast._next` so that `fast._next._next` exists
                if not fast or not fast._next:
                    return False

                slow = slow._next
                fast = fast._next._next

            return True
    \end{minted}
\end{figure}
